lsআমরা যারা অল্প স্বল্প জাভাস্ক্রিপ্ট পারি তাদের মধ্যে অনেকেই হিচ্-হাইকিং স্টাইলে জাভাস্ক্রিপ্ট শিখেছি। অর্থাৎ, হয়ত দেখা গেল কোন একটা প্রজেক্টে জাভাস্ক্রিপ্ট ব্যবহার করতে হয়েছে। বেসিক সিনট্যক্স w3schools এ দেখে তারপর মিনিটে পাঁচবার করে 'how to do X with js' করে করে প্রজেক্ট শেষ করে ফেলেছি। এভাবে শিখলে অনেক কিছুই অপূর্ণ থেকে যায়।

তাই এবার ভাবলাম একটু ভাল করে জেএস শেখা যাক। কেননা জেএস এমন একটা ল্যাঙ্গুয়েজ যেটা শিখলে কোন লস নাই। [Speaking Javascript]() পড়ে জেএস শেখার সময় যে বিষয়গুলো আমার মত হিচ্-হাইকার জেএস প্রোগ্রামারদের কাজে লাগতে পারে বলে মনে হয়েছে সেগুলো লিখে রাখতে চেষ্টা করেছি। 

## সেমিকোলন
জেএস এ সেমিকোলন না দিলেও হয়। জাভাস্ক্রিপ্ট ইন্জিনগুলোতে অটো সেমিকোলন এড করে নেয়ার ব্যবস্থা আছে। তবে কখনো কখনো সেটা কারেক্ট হয় না। যেমন-

```js
func()
[1, 2].forEach(...)
```
এখানে `func()` এর পর অটো সেমিকোলন এড হবে না। কারণ এখানে থার্ড ব্র্যাকেট `func()` এক্সপ্রেশনের রেজাল্টের ইন্ডেক্স হিসেবে ইন্টারপ্রেট হবে। তাই দেখা যচ্ছে ঝামেলা এড়াতে হলে সব সময় সেমিকোলন ব্যবহার করাই ভাল বুদ্ধি।


## স্ট্রিক্ট মোড
শেখার সময় `'strict mode'` ব্যবহার করা খুবই ভাল অভ্যাস হতে পারে। এতে জেএস এর বিভিন্ন ডেন্জারাস ফিচার অফ হয়ে যায় এবং বেশি ইরর মেসেজ দেখায়। যেমন-
```js
var s = 'string';
s.length = 100; // Invalid operation, but fails silently in normal mode.
```
আমরা জানি যে নরমাল মোডে দ্বিতীয় লাইনের কোন এফেক্ট হবে না। স্ট্রিক্ট মোডে ইরর দেখাবে। নন স্ট্রিক্ট মোড বা নরমাল মোডকে অনেকসময় স্লপি (sloppy) মোড বলা হয়। স্ট্রিক্ট মোড এক্টিভেট করতে হলে সাধারণত স্ক্রিপ্টের সবার শুরুতে ‍`'strict mode';` মোড লিখতে হয়। যেমন-
```js
'strict mode';
// code here...
```
সমম্পূর্ণ কোড স্ট্রিক্ট মোডে চালাতে না চাইলে প্রতি ফাংশনের জন্য আলাদাভাবে স্ট্রিক্ট মোড এক্টিভেট করা যায়। এজন্য ফাংশন ডেফিনেশনের শুরুতে `'strict mode';` লিখতে হয়। যেমন-
```js
function myFunc() {
    'strict mode';
    // code here
}
```

## `===` না ‍‍‍`==` ?
জেএস এ দুটি ভ্যালু সমান কিনা চেক করার জন্য দুটি উপায় আছে। `===/!===` এবং `==/!==`। প্রথম দুটি অপারেটরকে বলা হয় স্ট্রিক্ট ইকোয়্যালিটি ও ইনইকোয়্যালিটি এবং  পরের দুটিকে বলা হয় নরমাল বা লেনিয়েন্ট ইকোয়্যালিটি ও ইনইকোয়্যালিটি। প্রথম দুটি অপারেটর দুটি ডেটা সরাসরি তুলনা করে। এভাবে দুটি ডেটার টাইপ এবং ভ্যালু এক হলে তবেই সমান হবে। আর পরের দুটি অপারেটর প্রথমে দুটি ডেটাকে কনভার্ট করে সেইম টাইপে আনার চেষ্টা করে এবং তারপরে তুলনা করে। যেমন-
```js
-> '10' == 10
true
-> '10' === 10
false
-> 0 == false
true
-> 0 === true
false
```

আপাত দৃষ্টিতে `==` খুবই সুবিধাজনক মনে হতে পারে। কিন্তু জাভাস্ক্রিকপ্টের টাইপ কাস্টিং খুবই কনফিউজিং একটা  ব্যাপার। অনেক সময়ই অপ্রত্যাশিতভাবে টাইপ কাস্টিং হয়। যেমন-
```js
-> 0 == false
true // OK
-> 1 == true
true // Also OK
-> 2 == true
false // What?

-> '' == false
true // because empty strings are falsey
-> 'abc' == true
false // What? because booleans are first converted to numbers
```
দেখতেই পাচ্ছেন `==` ব্যবহার করলে ডিবাগিং করতে গিয়ে জান বের হয়ে যাওয়ার সমূহ সম্ভাবনা আছে। তাই কখনোই `==` ব্যবহার করা উচিত না। যেসব জায়গায় `==` ব্যবহার করা সুবিধাজনক মনে হয় সেসব জায়গায় একটু কষ্ট করে `===` ই ব্যবহার করা ভাল। 

## ইন্টিজার
* মজার ব্যাপার হরল জেএস এ কোন ইন্টিজার নাই। ফ্লোটিং পয়েন্ট ব্যবহার করেই ইন্টিজার রাখা হয়। এক্ষেত্রে ফ্লোটিং পয়েন্ট নাম্বারের ফ্র্যাকশন পার্টটা বাদ দিয়ে রাখা হয়। সমস্যা হল এভাবে -2^53 থেকে 2^53 সীমার মধ্যে ইন্টিজার সেইফলি রাখা যায়। এই সীমার বাইরে ইন্টিজার রাখতে গেলে বিভিন্ন ঝামেলা হয়। যেমন-
```js
-> (2**53 + 1) - 2**53
0
```
অনেক সময় এর বড় ইন্টিজার দরকার হতে পারে। সেক্ষেত্রে স্ট্রিং ব্যবহার করতে হবে।


* `parseInt()` দিয়ে ফ্লোটিং পয়েন্ট থেকে ইন্টিজারে কনভার্ট না করাই ভাল। কারণ এতে করে নাম্বারটি প্রথমে স্ট্রিং এ কনভার্ট হয় যা বিভিন্ন সমস্যা তৈরী করতে পারে।
যেমন `0.0000008` প্রথমে স্ট্রিং এ হবে `8e-7`, তারপরে হবে সেটা ইন্টিজারে হবে 8



## ট্রুথি ফলসি
যেসব ডেটা বুলিয়ান `true` তে কনভার্ট হয় সেগুলোকে বলা হয় ট্রুথি। আর বাকিগুলোকে বলা হয় ফলসি। `0, NaN, '', undefined, null` এবং স্বাভাবিকভাবেই `false` ফলসি। বাকি সব ট্রুথি। খালি অবজেক্ট এবং খালি অ্যারে সহ সকল অবজেক্ট ট্রুথি যা অনেক সময় স্বভাবিক নাও মনে হতে পারে। যেমন-
```js
-> Boolean([])
true
-> Boolean({})
true
-> Boolean('false')
true // Oviously, because all string except '' is truthy
-> Boolean(new Number(0))
true // because we are creating a number 'object'
-> Boolean(new String(''))
true
-> Boolean(new Boolean(false))
true // ;)
```

## NaN
`NaN` একটি ইরর ভ্যালু। নাম্বার নিয়ে কাজ করতে গিয়ে কোন সমস্যা হলে সাধারণত `NaN` রিটার্ণ করে। 
```js
-> Number('xyz')
NaN
-> Math.sqrt(-1)
NaN
-> typeof NaN
"number"
```
মজার ব্যপার হল `NaN` এমন একটা জিনিস যা নিজের সমান নয়।
```js
-> NaN === NaN
false
-> [0, 10, 20, NaN, 0].indexOf(NaN) // doesn't work
-1
```
কোন কিছু NaN কিনা দেখতে হলে `isNaN` ফাংশন ব্যবহার করতে হবে।
```js
-> isNaN(Math.sqrt(-1))
true
```

## অ্যারে
আমার জানি যে জেএস এ অ্যারে আসলে ভিতরে ম্যাপ। এ কারণে অ্যারেতে খালি জায়গা থাকতে পারে। অর্থাৎ যদি কোন অ্যারের প্রত্যেক  ইনডেক্সে যে উপাদান থাকবে এমন কোন কথা নেই। উদাহরণ দেখা যাক।
```js
-> var arr = [1, 2, 3];
-> arr
[ 1, 2, 3 ]
-> arr[4] = 10;
-> arr
[ 1, 2, 3, <1 empty item>, 10 ]
-> arr[3]
undefined
-> arr.length
5
```
খেয়াল করতে হবে যে কোন একটা ইন্ডক্স খালি থাকা আর ঐ ইন্ডেক্সে `undefined` রাখা কিনন্তু এক কথা নয়। যদিও খালি ইন্ডেক্স এক্সেস করতে গেলে `undefined` পাওয়া যায়।
```js
-> var arr = ['one', , 'two']; // this is how we difine an empty slot in array literal
-> var arr2 = ['one', undefined, 'two'];
-> 1 in arr
false
-> 1 in arr2
true
```
কিছু কিছু অ্যারে রিলেটেট অপারেটর এবং ফাংশন খালি ইন্ডেক্স ইগনোর করে আবার বাকিগুলো করে না। ব্যাপারটা ঝামেলার হতে পারে। তাই সাবধান থাকতে হবে।
```js
-> [1,2,,3].forEach(function(val){ console.log(val);});
1
2
3
-> ['a', ,'c'].join('-')
'a--c'
```

আরেকটা ব্যাপার হল `+` দিয়ে অ্যারে যোগ করা যায় নাা
```js
-> [1, 2] + [3]
'1,23'
```
কারণটা হল জেএস এ অবজেক্টের উপর অপারেটর এপ্লাই করলে তা আগে প্রিমিটিভ ভ্যালুতে কনভার্ট হয়। এক্ষেত্রে অ্যারে প্রথমে স্ট্রিং এ কনভার্ট হচ্ছে।  `[1, 2] + [3] -> '1,2' + '3' -> '1,23'`

